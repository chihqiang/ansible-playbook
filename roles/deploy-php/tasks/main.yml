# 添加 Git 安全目录例外（优先执行，解决 Git 2.35+ 版本的目录所有权不匹配报错）
# 原理：将应用目录添加到 Git 全局安全列表，跳过所有者校验（因 Ansible 执行用户与目录所有者可能不一致）
- name: 添加 Git 安全目录例外
  command: git config --global --add safe.directory "{{ wwwroot }}/{{ domain }}"
  become: true  # 全局 Git 配置需 root 权限才能生效
  changed_when: false  # 重复执行无状态变更，标记为未修改
  when: (wwwroot | default('')) != '' and (domain | default('')) != ''  # 变量非空时才执行，避免路径错误

# 创建应用目录并设置初始权限（提前初始化目录，避免后续拉取代码时权限不足）
# 核心：确保目录所有者为 Web 服务用户，基础权限 0755（所有者读写执行，其他只读）
- name: 创建应用目录并授权
  file:
    path: "{{ wwwroot }}/{{ domain }}"  # 目标目录（网站根路径 + 域名，如 /data/wwwroot/www.think.com）
    owner: "{{ app_user }}"  # Web 服务运行用户（如 www、nginx，确保后续文件可读写）
    group: "{{ app_group }}"  # 对应运行组，与所有者一致确保权限统一
    mode: '0755'  # 目录基础权限，符合最小权限原则
    state: directory  # 确保目录存在（不存在则创建，已存在不操作）
    recurse: yes  # 递归授权子目录（若目录已存在，子目录也同步权限）
  become: true  # 创建系统级目录（/data/wwwroot）需 root 权限

# 拉取最新代码到应用目录（核心步骤：从 Git 仓库获取项目源代码）
- name: 拉取最新代码到应用目录
  git:
    repo: "{{ app_repo }}"  # Git 仓库地址（支持 HTTP/SSH 协议，如 gitee、github 仓库）
    dest: "{{ wwwroot }}/{{ domain }}"  # 代码拉取目标目录
    version: "{{ app_version | default('main') }}"  # 拉取版本（分支/标签/commit ID，默认 main 分支）
    update: yes  # 存在旧代码时自动更新
    force: yes  # 强制覆盖本地修改，避免因本地文件冲突导致拉取失败
    accept_hostkey: yes  # 首次拉取 SSH 协议仓库时，自动接受主机密钥（避免交互阻塞）
    depth: 1  # 仅拉取最新 1 次提交，减少传输耗时（部署场景无需历史提交记录）
  register: git_pull_result  # 注册拉取结果，供后续任务判断
  until: git_pull_result is succeeded  # 拉取失败时自动重试
  retries: 3  # 重试次数（应对网络波动）
  delay: 5  # 重试间隔（5 秒）
  become: true  # 用普通用户（如 ansible 执行用户）拉取，避免代码文件所有者为 root

# 统一设置项目文件权限（覆盖 Git 拉取时生成的默认权限，确保 Web 服务可正常访问）
# 核心：所有文件/目录所有者统一为 Web 用户，避免因权限不匹配导致 403 错误
- name: 统一设置项目文件权限
  file:
    path: "{{ wwwroot }}/{{ domain }}"  # 目标项目根目录
    owner: "{{ app_user }}"  # 归属于 Web 服务用户
    group: "{{ app_group }}"  # 归属于 Web 服务组
    recurse: yes  # 递归应用到所有子文件/目录
    mode: '0755'  # 目录权限（文件会继承基础权限，后续可通过细粒度配置调整）
  become: true  # 修改文件权限需 root 权限

# 安装 Composer 依赖（适配服务器实际 Composer 路径，生产环境优化配置）
# 核心：安装项目运行必需的 PHP 第三方依赖，跳过开发依赖减少资源占用
- name: 安装 Composer 依赖
  shell:
    cmd: |
      cd "{{ wwwroot }}/{{ domain }}"  # 进入项目根目录（Composer 需读取 composer.json）
      /etc/php/{{ php_version }}/composer install --no-dev --optimize-autoloader --no-interaction
  register: composer_install_result  # 注册安装结果
  until: composer_install_result is succeeded  # 安装失败自动重试
  retries: 2  # 重试次数（应对 Composer 镜像网络波动）
  delay: 3  # 重试间隔（3 秒）
  become: true  # 用普通用户执行，避免依赖文件权限异常

- name: 创建多目录并授权
  file:
    path: "{{ item }}"  # 循环遍历多目录列表
    state: directory    # 确保目录存在（不存在则创建）
    owner: "{{ app_user }}"  # Web 用户（如 www、nginx、apache）
    group: "{{ app_group }}" # 对应 Web 用户组
    mode: '0775'        # 目录权限：所有者/组可读写执行，其他只读（符合安全规范）
    recurse: yes        # 递归授权子目录和文件（若目录已存在）
  become: true          # 需 root 权限创建/修改目录权限
  loop:                 # 多目录列表（根据实际需求扩展）
    - "{{ wwwroot }}/{{ domain }}/runtime"

# 检查 Nginx 站点配置文件是否已存在（前置判断，避免重复创建覆盖现有配置）
# 核心：仅首次部署时生成配置，后续手动修改的配置不会被覆盖
- name: 检查 Nginx 站点配置文件状态
  stat:
    path: "/etc/nginx/conf.d/{{ domain }}.conf"  # Nginx 站点配置文件路径（以域名为文件名，便于识别）
  register: nginx_conf_stat  # 注册检查结果（存在/不存在）
  become: true  # 访问 /etc/nginx 目录需 root 权限

# 生成 Nginx 站点配置（仅首次部署执行，通过模板动态适配项目环境）
# 核心：基于 Jinja2 模板生成专属配置，适配项目路径、域名、PHP 版本等
- name: 生成 Nginx 站点配置
  template:
    src: nginx-php.conf.j2  # 配置模板文件（.j2 后缀，支持变量替换）
    dest: "/etc/nginx/conf.d/{{ domain }}.conf"  # 目标配置文件路径（Nginx 自动加载 conf.d 目录下的 .conf 文件）
    owner: root  # 配置文件所有者为 root（避免普通用户篡改）
    group: root  # 配置文件所属组为 root
    mode: '0644'  # 配置文件权限：只读（所有者可写，其他只读，符合系统配置规范）
  when: not nginx_conf_stat.stat.exists  # 仅当配置文件不存在时执行（避免覆盖）
  become: true  # 写入 /etc/nginx 目录需 root 权限
  notify: reload nginx  # 配置生成后触发重载 Nginx（使配置生效，不中断现有连接）